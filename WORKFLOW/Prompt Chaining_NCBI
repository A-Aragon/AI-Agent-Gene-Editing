import json
import os
import re
import requests
import urllib.parse
from openai import OpenAI

# ----------------------------
# Initialize OpenAI client
# ----------------------------
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# ----------------------------
# Entrez API Functions
# ----------------------------

def esearch(db, term, **kwargs):
    base_url = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi"
    params = {"db": db, "term": term, "retmode": "json", "retmax": 20, "retstart": 0, "usehistory": "y"}
    params.update(kwargs)
    clean_params = {k: v for k, v in params.items() if v is not None}
    full_url = f"{base_url}?{urllib.parse.urlencode(clean_params)}"
    try:
        response = requests.get(full_url)
        response.raise_for_status()
        data = response.json()
        if "esearchresult" not in data:
            raise ValueError("No esearchresult found.")
        return data
    except (requests.exceptions.RequestException, json.JSONDecodeError, ValueError) as e:
        raise Exception(f"ESearch error: {e}")

def esummary(db, ids, **kwargs):
    base_url = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi"
    params = {"db": db, "id": ",".join(ids), "retmode": "json"}
    params.update(kwargs)
    clean_params = {k: v for k, v in params.items() if v is not None}
    full_url = f"{base_url}?{urllib.parse.urlencode(clean_params)}"
    try:
        response = requests.get(full_url)
        response.raise_for_status()
        return response.json()
    except (requests.exceptions.RequestException, json.JSONDecodeError) as e:
        raise Exception(f"ESummary error: {e}")

# ----------------------------
# CRISPR API Functions
# ----------------------------

def get_crisprs_by_exon(species, exon_ids):
    url = "https://wge.stemcell.sanger.ac.uk/api/crispr_search"
    params = {"species": species.capitalize(), "exon_id[]": exon_ids}
    response = requests.get(url, params=params)
    return handle_response(response)

def get_off_targets(species, sequence, pam_right):
    url = "https://wge.stemcell.sanger.ac.uk/api/off_targets_by_seq"
    params = {"species": species, "seq": sequence, "pam_right": str(pam_right).lower()}
    response = requests.get(url, params=params)
    return handle_response(response)

def get_forecast_predictions(target, pam_position):
    url = "https://elixir.ut.ee/forecast/api/predict"
    payload = {"target": target, "pam_position": pam_position}
    headers = {"Content-Type": "application/json"}
    response = requests.post(url, json=payload, headers=headers)
    return handle_response(response)

def get_gene_info(symbol):
    url = "https://genomecrispr.dkfz.de/api/genes"
    headers = {"Content-Type": "application/json"}
    data = {"query": symbol, "field": "symbol"}
    response = requests.post(url, headers=headers, json=data)
    return handle_response(response)

def get_sgrnas(symbol):
    url = "https://genomecrispr.dkfz.de/api/sgrnas/symbol"
    headers = {"Content-Type": "application/json"}
    data = {"query": symbol}
    response = requests.post(url, headers=headers, json=data)
    return handle_response(response)

def get_screening_experiments(symbol):
    sgrna_data = get_sgrnas(symbol)
    if sgrna_data:
        sgrna_pubmed_ids = [item.get('pubmed') for item in sgrna_data if item.get('pubmed') != 'N/A']
        unique_pubmed_ids = sorted(list(set(sgrna_pubmed_ids)), key=int)
        url = "https://genomecrispr.dkfz.de/api/experiments"
        headers = {"Content-Type": "application/json"}
        data = {"pubmed": {"$in": unique_pubmed_ids}}
        response = requests.post(url, headers=headers, json=data)
        return handle_response(response)
    else:
        return None

def handle_response(response):
    if response.status_code != 200:
        print(f"Error {response.status_code}: {response.text}")
        return None
    try:
        result = response.json()
        if not result:
            print("No data returned.")
        return result
    except json.JSONDecodeError:
        print("Failed to decode JSON response:", response.text)
        return None

# ----------------------------
# Forecast Repair API Functions
# ----------------------------

def get_forecast_repair_predictions(target, pam_position, context):
    url = "https://elixir.ut.ee/forecast-repair/api/predict"
    payload = {"target": target, "pam_position": pam_position, "context": context}
    headers = {"Content-Type": "application/json"}
    response = requests.post(url, json=payload, headers=headers)
    return handle_response(response)

# Clasificación de mutaciones

def classify_mutation_type(mutation):
    if mutation.startswith("I1"):
        return "Ins (1bp)"
    elif mutation.startswith("I"):
        return "Inserción (>1 bp)"
    elif mutation.startswith("D"):
        size_match = re.match(r"D(\d+)", mutation)
        size = int(size_match.group(1)) if size_match else 0
        if size <= 2:
            return "Deleción (1-2 bp)"
        elif 3 <= size <= 9:
            return "Deleción (3-9 bp)"
        else:
            return "Deleción (>9 bp)"
    return "Otro tipo"

# Procesamiento de respuesta

def parse_all_predictions(response_data):
    forecasts = []
    try:
        rows = response_data["data"].split("\n")[1:]
        for row in rows:
            mutation_data = row.split(",")
            if len(mutation_data) >= 4:
                mutation = mutation_data[1]
                inserted_sequence = mutation_data[2] if mutation_data[2] != "" else "No insertada"
                prediction_score = float(mutation_data[3])
                forecasts.append({
                    "mutation": mutation,
                    "type": classify_mutation_type(mutation),
                    "inserted_sequence": inserted_sequence,
                    "prediction_score": prediction_score
                })
    except Exception as e:
        print(f"[ERROR] Error procesando datos de la API: {e}")
    return forecasts

def get_top_predictions(forecasts, top_n=10):
    return sorted(forecasts, key=lambda x: x['prediction_score'], reverse=True)[:top_n]

# ----------------------------
# Function Map
# ----------------------------
function_map = {
    "get_crisprs_by_exon": get_crisprs_by_exon,
    "get_off_targets": get_off_targets,
    "get_forecast_predictions": get_forecast_predictions,
    "get_gene_info": get_gene_info,
    "get_sgrnas": get_sgrnas,
    "get_screening_experiments": get_screening_experiments,
    "esearch": esearch,
    "esummary": esummary,
    "get_forecast_repair_predictions": get_forecast_repair_predictions,
}

# ----------------------------
# Define OpenAI Tools
# ----------------------------
tools = [
    {"type": "function", "function": {
        "name": "get_crisprs_by_exon",
        "description": "Retrieve CRISPR guides for a species and list of exon IDs.",
        "parameters": {"type": "object", "properties": {"species": {"type": "string"}, "exon_ids": {"type": "array", "items": {"type": "string"}}}, "required": ["species", "exon_ids"]}
    }},
    {"type": "function", "function": {
        "name": "get_off_targets",
        "description": "Retrieve off-targets for a CRISPR sequence.",
        "parameters": {"type": "object", "properties": {"species": {"type": "string"}, "sequence": {"type": "string"}, "pam_right": {"type": "boolean"}}, "required": ["species", "sequence", "pam_right"]}
    }},
    {"type": "function", "function": {
        "name": "get_forecast_predictions",
        "description": "Retrieve CRISPR editing predictions using Elixir Forecast API.",
        "parameters": {"type": "object", "properties": {"target": {"type": "string"}, "pam_position": {"type": "integer"}}, "required": ["target", "pam_position"]}
    }},
    {"type": "function", "function": {
        "name": "get_gene_info",
        "description": "Retrieve gene information from GenomeCRISPR.",
        "parameters": {"type": "object", "properties": {"symbol": {"type": "string"}}, "required": ["symbol"]}
    }},
    {"type": "function", "function": {
        "name": "get_sgrnas",
        "description": "Retrieve sgRNAs associated with a gene from GenomeCRISPR.",
        "parameters": {"type": "object", "properties": {"symbol": {"type": "string"}}, "required": ["symbol"]}
    }},
    {"type": "function", "function": {
        "name": "get_screening_experiments",
        "description": "Retrieve CRISPR screening experiments based on a gene symbol.",
        "parameters": {"type": "object", "properties": {"symbol": {"type": "string"}}, "required": ["symbol"]}
    }},
    {"type": "function", "function": {
        "name": "esearch",
        "description": "Search the Entrez database.",
        "parameters": {"type": "object", "properties": {
            "db": {"type": "string"},
            "term": {"type": "string"},
            "kwargs": {"type": "object", "properties": {
                "retmax": {"type": "integer"},
                "retstart": {"type": "integer"},
                "reldate": {"type": "integer"},
                "datetype": {"type": "string"},
                "rettype": {"type": "string"},
                "sort": {"type": "string"}
            }}
        }, "required": ["db", "term"]}
    }},
    {"type": "function", "function": {
        "name": "esummary",
        "description": "Get summaries for documents in the Entrez database.",
        "parameters": {"type": "object", "properties": {
            "db": {"type": "string"},
            "ids": {"type": "array", "items": {"type": "string"}},
            "kwargs": {"type": "object", "properties": {
                "version": {"type": "string"}
            }}
        }, "required": ["db", "ids"]}
    }},
    {"type": "function", "function": {
        "name": "get_forecast_repair_predictions",
        "description": "Retrieve CRISPR editing predictions using Elixir Forecast Repair API.",
        "parameters": {"type": "object", "properties": {
            "target": {"type": "string"},
            "pam_position": {"type": "integer"},
            "context": {"type": "string"}
        }, "required": ["target", "pam_position", "context"]}
    }}
]

system_prompt = "You are an assistant that helps find CRISPR guides, off-targets, gene information, search Entrez databases, and predicts CRISPR repair outcomes."

# ----------------------------
# User Interaction
# ----------------------------

user_input = input("Enter your request (e.g., 'gene info for POLR2A', 'guides for exon ENSMUSE00000106755', 'search pubmed for crispr', 'summarize pubmed ids 12345, 67890', 'Predict repair outcomes for target sequence ATCG..., pam position 20, context Lig3'): ")
messages = [{"role": "system", "content": system_prompt}, {"role": "user", "content": user_input}]

# ----------------------------
# Call OpenAI Model
# ----------------------------

completion = client.chat.completions.create(model="gpt-4o", messages=messages, tools=tools)

if completion.choices and completion.choices[0].message.tool_calls:
    tool_call = completion.choices[0].message.tool_calls[0]
    function_name = tool_call.function.name
    function_args = json.loads(tool_call.function.arguments)

    print("\nGPT decided to call:")
    print("Function:", function_name)
    print("Arguments:", function_args)

    # Call the corresponding function dynamically
    func = function_map.get(function_name)
    if func:
        # Handle kwargs for esearch and esummary
        if function_name in ["esearch", "esummary"] and "kwargs" in function_args and function_args["kwargs"]:
            result = func(function_args["db"], function_args["term"] if "term" in function_args else function_args["ids"], **function_args["kwargs"])
        elif function_name == "esummary":
            result = func(function_args["db"], function_args["ids"])
        elif function_name == "get_forecast_repair_predictions":
            result = func(**function_args)
            if result and "data" in result:
                parsed_predictions = parse_all_predictions(result)
                top_predictions = get_top_predictions(parsed_predictions)

                print("\nTop 10 predicciones con mayor score:\n")
                for i, forecast in enumerate(top_predictions, start=1):
                    print(f"{i}. Mutación: {forecast['mutation']}")
                    print(f"  Tipo de mutación: {forecast['type']}")
                    print(f"  Secuencia insertada: {forecast['inserted_sequence']}")
                    print(f"  Score de predicción: {forecast['prediction_score']:.6f}")
                    print("-" * 40)
            else:
                print("[ERROR] No se recibió una respuesta válida de la API.")
        else:
            result = func(**function_args)

        print("\nFunction Result:", json.dumps(result, indent=2) if result else "\nNo results returned.")
    else:
        print(f"Unknown function: {function_name}")
else:
    print("GPT did not decide to call any function.")