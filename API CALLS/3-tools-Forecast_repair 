import json
import os
import re
import requests
from openai import OpenAI
from pydantic import BaseModel, Field

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def get_forecast_predictions(target, pam_position, context):
    url = "https://elixir.ut.ee/forecast-repair/api/predict"
    payload = {"target": target, "pam_position": pam_position, "context": context}
    headers = {"Content-Type": "application/json"}

    response = requests.post(url, json=payload, headers=headers)
    if response.status_code == 200:
        return response.json()
    else:
        print("[ERROR] API Response:", response.status_code, response.text)
        return None

# Clasificación de mutaciones

def classify_mutation_type(mutation):
    if mutation.startswith("I1"):
        return "Ins (1bp)"
    elif mutation.startswith("I"):
        return "Inserción (>1 bp)"
    elif mutation.startswith("D"):
        size_match = re.match(r"D(\d+)", mutation)
        size = int(size_match.group(1)) if size_match else 0
        if size <= 2:
            return "Deleción (1-2 bp)"
        elif 3 <= size <= 9:
            return "Deleción (3-9 bp)"
        else:
            return "Deleción (>9 bp)"
    return "Otro tipo"

# Procesamiento de respuesta

def parse_all_predictions(response_data):
    forecasts = []
    try:
        rows = response_data["data"].split("\n")[1:]
        for row in rows:
            mutation_data = row.split(",")
            if len(mutation_data) >= 4:
                mutation = mutation_data[1]
                inserted_sequence = mutation_data[2] if mutation_data[2] != "" else "No insertada"
                prediction_score = float(mutation_data[3])
                forecasts.append({
                    "mutation": mutation,
                    "type": classify_mutation_type(mutation),
                    "inserted_sequence": inserted_sequence,
                    "prediction_score": prediction_score
                })
    except Exception as e:
        print(f"[ERROR] Error procesando datos de la API: {e}")
    return forecasts

def get_top_predictions(forecasts, top_n=10):
    return sorted(forecasts, key=lambda x: x['prediction_score'], reverse=True)[:top_n]

# Solicitar datos al usuario
target_input = input("Introduce la secuencia CRISPR objetivo: ")
pam_position_input = int(input("Introduce la posición del PAM: "))
context_input = input("Introduce el contexto (Ej. Lig3, Dclre1c, Polq, etc.): ")

# Obtener respuesta de la API
response = get_forecast_predictions(target_input, pam_position_input, context_input)
if response and "data" in response:
    parsed_predictions = parse_all_predictions(response)
    top_predictions = get_top_predictions(parsed_predictions)
    
    print("\nTop 10 predicciones con mayor score:\n")
    for i, forecast in enumerate(top_predictions, start=1):
        print(f"{i}. Mutación: {forecast['mutation']}")
        print(f"   Tipo de mutación: {forecast['type']}")
        print(f"   Secuencia insertada: {forecast['inserted_sequence']}")
        print(f"   Score de predicción: {forecast['prediction_score']:.6f}")
        print("-" * 40)
else:
    print("[ERROR] No se recibió una respuesta válida de la API.")



